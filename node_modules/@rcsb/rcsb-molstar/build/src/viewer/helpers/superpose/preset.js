"use strict";
/**
 * Copyright (c) 2021 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author Yana Rose
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.RcsbSuperpositionRepresentationPreset = void 0;
var tslib_1 = require("tslib");
var representation_preset_1 = require("molstar/lib/mol-plugin-state/builder/structure/representation-preset");
var param_definition_1 = require("molstar/lib/mol-util/param-definition");
var mol_state_1 = require("molstar/lib/mol-state");
var reprBuilder = representation_preset_1.StructureRepresentationPresetProvider.reprBuilder;
var updateFocusRepr = representation_preset_1.StructureRepresentationPresetProvider.updateFocusRepr;
var transform_1 = require("molstar/lib/mol-state/transform");
exports.RcsbSuperpositionRepresentationPreset = (0, representation_preset_1.StructureRepresentationPresetProvider)({
    id: 'preset-superposition-representation-rcsb',
    display: {
        group: 'Superposition',
        name: 'Alignment',
        description: 'Show representations based on the structural alignment data.'
    },
    params: function () { return (tslib_1.__assign(tslib_1.__assign({}, representation_preset_1.StructureRepresentationPresetProvider.CommonParams), { selectionExpressions: param_definition_1.ParamDefinition.Value([]) })); },
    apply: function (ref, params, plugin) {
        var _a, _b, _c, _d, _e, _f;
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var structureCell, structure, cartoonProps, components, representations, _i, _g, expr, comp, _h, update, builder, typeParams, color, typeProps, reprProps;
            var _j, _k;
            return tslib_1.__generator(this, function (_l) {
                switch (_l.label) {
                    case 0:
                        structureCell = mol_state_1.StateObjectRef.resolveAndCheck(plugin.state.data, ref);
                        if (!structureCell)
                            return [2 /*return*/, {}];
                        structure = structureCell.obj.data;
                        cartoonProps = { sizeFactor: structure.isCoarseGrained ? 0.8 : 0.2 };
                        components = Object.create(null);
                        representations = Object.create(null);
                        _i = 0, _g = params.selectionExpressions;
                        _l.label = 1;
                    case 1:
                        if (!(_i < _g.length)) return [3 /*break*/, 5];
                        expr = _g[_i];
                        return [4 /*yield*/, plugin.builders.structure.tryCreateComponentFromExpression(structureCell, expr.expression, expr.label, { label: expr.label })];
                    case 2:
                        comp = _l.sent();
                        Object.assign(components, (_j = {}, _j[expr.label] = comp, _j));
                        _h = reprBuilder(plugin, params), update = _h.update, builder = _h.builder, typeParams = _h.typeParams, color = _h.color;
                        typeProps = tslib_1.__assign({}, typeParams);
                        if (expr.type === 'cartoon') {
                            Object.assign(typeProps, tslib_1.__assign({}, cartoonProps));
                        }
                        reprProps = {
                            type: expr.type,
                            typeParams: typeProps,
                            color: color
                        };
                        if (expr.color) {
                            Object.assign(reprProps, {
                                color: 'uniform',
                                colorParams: { value: expr.color }
                            });
                        }
                        Object.assign(representations, (_k = {},
                            _k[expr.label] = builder.buildRepresentation(update, comp, reprProps, {
                                tag: expr.tag,
                                // this only hides the visuals but the state UI will still indicate them as visible
                                initialState: { isHidden: expr.isHidden || false }
                            }),
                            _k));
                        // make sure UI state is consistent
                        if (((_a = comp === null || comp === void 0 ? void 0 : comp.cell) === null || _a === void 0 ? void 0 : _a.state) && expr.isHidden) {
                            transform_1.StateTransform.assignState((_b = comp === null || comp === void 0 ? void 0 : comp.cell) === null || _b === void 0 ? void 0 : _b.state, { isHidden: true });
                        }
                        return [4 /*yield*/, update.commit({ revertOnError: false })];
                    case 3:
                        _l.sent();
                        _l.label = 4;
                    case 4:
                        _i++;
                        return [3 /*break*/, 1];
                    case 5: 
                    // needed to apply same coloring scheme to focus representation
                    return [4 /*yield*/, updateFocusRepr(plugin, structure, (_d = (_c = params.theme) === null || _c === void 0 ? void 0 : _c.focus) === null || _d === void 0 ? void 0 : _d.name, (_f = (_e = params.theme) === null || _e === void 0 ? void 0 : _e.focus) === null || _f === void 0 ? void 0 : _f.params)];
                    case 6:
                        // needed to apply same coloring scheme to focus representation
                        _l.sent();
                        return [2 /*return*/, representations];
                }
            });
        });
    }
});
