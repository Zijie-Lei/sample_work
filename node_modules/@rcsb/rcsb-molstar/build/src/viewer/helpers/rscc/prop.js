"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RSCCProvider = exports.RSCCParams = exports.RSCC = void 0;
var tslib_1 = require("tslib");
var graphql_client_1 = require("molstar/lib/mol-util/graphql-client");
var synchronous_1 = require("molstar/lib/mol-task/execution/synchronous");
var resolution_gql_1 = require("./resolution.gql");
var param_definition_1 = require("molstar/lib/mol-util/param-definition");
var rscc_thresholds_json_1 = tslib_1.__importDefault(require("./rscc-thresholds.json"));
var custom_model_property_1 = require("molstar/lib/mol-model-props/common/custom-model-property");
var custom_property_1 = require("molstar/lib/mol-model/custom-property");
var model_1 = require("molstar/lib/mol-model/structure/model");
var wrapper_1 = require("molstar/lib/mol-model-props/common/wrapper");
var indexed_1 = require("molstar/lib/commonjs/mol-model/structure/model/properties/custom/indexed");
var structure_1 = require("molstar/lib/mol-model/structure/structure");
var prop_1 = require("molstar/lib/extensions/rcsb/validation-report/prop");
var array_1 = require("molstar/lib/mol-util/array");
var RSCC;
(function (RSCC) {
    function getScore(e) {
        if (!structure_1.Unit.isAtomic(e.unit))
            return [-1, 'No Score'];
        var prop = exports.RSCCProvider.get(e.unit.model).value;
        if (!prop || !prop.data)
            return [-1, 'No Score'];
        var rI = e.unit.residueIndex[e.element];
        return prop.data.score.has(rI) ? prop.data.score.get(rI) : [-1, 'No Score'];
    }
    RSCC.getScore = getScore;
    var _emptyArray = [];
    function getCategories(structure) {
        if (!structure || structure.isEmpty)
            return _emptyArray;
        var prop = exports.RSCCProvider.get(structure.models[0]).value;
        if (!prop || !prop.data)
            return _emptyArray;
        return prop.data.category;
    }
    RSCC.getCategories = getCategories;
    function isApplicable(ctx) {
        return !!ctx.structure && prop_1.ValidationReport.isApplicable(ctx.structure.models[0]) && model_1.Model.isFromXray(ctx.structure.models[0]) && model_1.Model.probablyHasDensityMap(ctx.structure.models[0]);
    }
    RSCC.isApplicable = isApplicable;
    function obtain(ctx, model, props) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _a, _b;
            return tslib_1.__generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        _a = {};
                        _b = { info: wrapper_1.PropertyWrapper.createInfo() };
                        return [4 /*yield*/, _obtain(ctx, model, props)];
                    case 1: return [2 /*return*/, (_a.value = (_b.data = _c.sent(), _b), _a)];
                }
            });
        });
    }
    RSCC.obtain = obtain;
    function _obtain(ctx, model, _props) {
        var _a, _b;
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var rscc, resolution;
            return tslib_1.__generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        rscc = (_b = (_a = prop_1.ValidationReportProvider.get(model)) === null || _a === void 0 ? void 0 : _a.value) === null || _b === void 0 ? void 0 : _b.rscc;
                        if (!rscc)
                            return [2 /*return*/];
                        return [4 /*yield*/, fetchResolution(ctx, model, DefaultBaseUrl)];
                    case 1:
                        resolution = _c.sent();
                        if (!resolution)
                            return [2 /*return*/];
                        return [2 /*return*/, createSourceMap(model, rscc, resolution)];
                }
            });
        });
    }
    function createSourceMap(model, rscc, resolution) {
        var ret = new Map();
        var categories = [];
        var resolutionBin = Math.floor(resolution * 10);
        var toCategory = function (value, thresholds) {
            if (value > thresholds[0])
                return 'Very well resolved';
            if (value > thresholds[1])
                return 'Well resolved';
            if (value > thresholds[2])
                return 'Low confidence';
            return 'Very low confidence';
        };
        var offsets = model.atomicHierarchy.residueAtomSegments.offsets;
        rscc.forEach(function (v, k) {
            var label_comp_id = model.atomicHierarchy.atoms.label_comp_id.value(offsets[k]);
            var residue = rscc_thresholds_json_1.default[label_comp_id];
            if (!residue)
                return;
            var bin = residue[resolutionBin];
            var category = 'No score';
            if (!bin) {
                // handle 'out-of-range' case
                var keys = Object.keys(residue);
                var _a = [+keys[0], +keys[keys.length - 1]], min = _a[0], max = _a[1];
                if (resolutionBin < min)
                    category = toCategory(v, residue[keys[0]]);
                if (resolutionBin > max)
                    category = toCategory(v, residue[keys[keys.length - 1]]);
            }
            else {
                category = toCategory(v, bin);
            }
            ret.set(k, [v, category]);
            (0, array_1.arraySetAdd)(categories, category);
        });
        return {
            score: indexed_1.IndexedCustomProperty.fromResidueMap(ret),
            category: categories
        };
    }
})(RSCC = exports.RSCC || (exports.RSCC = {}));
exports.RSCCParams = {};
exports.RSCCProvider = custom_model_property_1.CustomModelProperty.createProvider({
    label: 'RSCC Score',
    descriptor: (0, custom_property_1.CustomPropertyDescriptor)({
        name: 'rscc_score'
    }),
    type: 'static',
    defaultParams: exports.RSCCParams,
    getParams: function () { return exports.RSCCParams; },
    isApplicable: function (data) { return RSCC.isApplicable(data); },
    obtain: function (ctx, data, props) { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
        var p;
        var _a, _b;
        return tslib_1.__generator(this, function (_c) {
            switch (_c.label) {
                case 0: return [4 /*yield*/, prop_1.ValidationReportProvider.attach(ctx, data)];
                case 1:
                    _c.sent();
                    if (!((_a = prop_1.ValidationReportProvider.get(data).value) === null || _a === void 0 ? void 0 : _a.rscc) || ((_b = prop_1.ValidationReportProvider.get(data).value) === null || _b === void 0 ? void 0 : _b.rscc.size) === 0)
                        throw Error('No RSCC available');
                    p = tslib_1.__assign(tslib_1.__assign({}, param_definition_1.ParamDefinition.getDefaultValues(exports.RSCCParams)), props);
                    return [4 /*yield*/, RSCC.obtain(ctx, data, p)];
                case 2: return [2 /*return*/, _c.sent()];
            }
        });
    }); }
});
var DefaultBaseUrl = 'https://data.rcsb.org/graphql';
function fetchResolution(ctx, model, serverUrl) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var client, result;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    client = new graphql_client_1.GraphQLClient(serverUrl, ctx.assetManager);
                    return [4 /*yield*/, client.request(synchronous_1.SyncRuntimeContext, resolution_gql_1.resolution_gql, { entry_id: model.entryId })];
                case 1:
                    result = _a.sent();
                    return [2 /*return*/, result.data.entry.rcsb_entry_info.resolution_combined];
            }
        });
    });
}
