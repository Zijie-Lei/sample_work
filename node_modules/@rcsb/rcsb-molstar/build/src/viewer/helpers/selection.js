"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.targetToLoci = exports.rangeToTest = exports.toRange = exports.createSelectionExpressions = exports.normalizeTargets = void 0;
var tslib_1 = require("tslib");
var builder_1 = require("molstar/lib/mol-script/language/builder");
var structure_selection_query_1 = require("molstar/lib/mol-plugin-state/helpers/structure-selection-query");
var structure_1 = require("molstar/lib/mol-model/structure");
var compiler_1 = require("molstar/lib/mol-script/runtime/query/compiler");
/**
 * This serves as adapter between the strucmotif-/BioJava-approach to identify transformed chains and the Mol* way.
 * Looks for 'structOperId', converts it to an 'operatorName', and removes the original value. This will
 * override pre-existing 'operatorName' values.
 * @param targets collection to process
 * @param structure parent structure
 * @param operatorName optional value to which missing operators are set
 */
function normalizeTargets(targets, structure, operatorName) {
    if (operatorName === void 0) { operatorName = undefined; }
    return targets.map(function (t) {
        if (t.structOperId) {
            var structOperId = t.structOperId, others = tslib_1.__rest(t, ["structOperId"]);
            var oper = toOperatorName(structure, structOperId);
            return tslib_1.__assign(tslib_1.__assign({}, others), { operatorName: oper });
        }
        return t.operatorName ? t : tslib_1.__assign(tslib_1.__assign({}, t), { operatorName: operatorName });
    });
}
exports.normalizeTargets = normalizeTargets;
function toOperatorName(structure, expression) {
    function join(opers) {
        // this makes the assumptions that '1' is the identity operator
        if (!opers || !opers.length)
            return '1';
        if (opers.length > 1) {
            // Mol* operators are right-to-left
            return opers[1] + 'x' + opers[0];
        }
        return opers[0];
    }
    for (var _i = 0, _a = structure.units; _i < _a.length; _i++) {
        var unit = _a[_i];
        var assembly = unit.conformation.operator.assembly;
        if (!assembly)
            continue;
        if (expression === join(assembly.operList))
            return "ASM_".concat(assembly.operId);
    }
    // TODO better error handling?
    throw Error("Unable to find expression '".concat(expression, "'"));
}
/**
 * Convert a selection to an array of selection expressions.
 * @param labelBase the base label that will appear in the UI (e.g., the entry ID)
 * @param selection a selection by Range or a set of Targets
 */
function createSelectionExpressions(labelBase, selection) {
    if (selection) {
        if ('labelAsymId' in selection) {
            var target = selection;
            var residues = (target.labelSeqRange) ? (0, exports.toRange)(target.labelSeqRange.beg, target.labelSeqRange.end) : [];
            var test = rangeToTest(target.labelAsymId, residues);
            var label = labelFromProps(labelBase, target.labelAsymId, residues);
            return [{
                    expression: builder_1.MolScriptBuilder.struct.generator.atomGroups(test),
                    label: "".concat(label),
                    type: 'cartoon',
                    tag: 'polymer'
                }];
        }
        else if (Array.isArray(selection)) {
            var expression = targetsToExpression(selection);
            return [{
                    expression: expression,
                    label: "".concat(labelBase),
                    type: 'ball-and-stick',
                    tag: 'polymer'
                }];
        }
        else {
            throw Error('Unable to handle selection: ' + selection);
        }
    }
    else {
        return [
            {
                expression: structure_selection_query_1.StructureSelectionQueries.polymer.expression,
                label: "".concat(labelBase, " - Polymers"),
                type: 'cartoon',
                tag: 'polymer'
            },
            {
                expression: structure_selection_query_1.StructureSelectionQueries.ligand.expression,
                label: "".concat(labelBase, " - Ligands"),
                type: 'ball-and-stick',
                tag: 'ligand'
            },
            {
                expression: structure_selection_query_1.StructureSelectionQueries.ion.expression,
                label: "".concat(labelBase, " - Ions"),
                type: 'ball-and-stick',
                tag: 'ion'
            },
            {
                expression: structure_selection_query_1.StructureSelectionQueries.branched.expression,
                label: "".concat(labelBase, " - Carbohydrates"),
                type: 'carbohydrate',
                tag: 'branched-snfg-3d'
            },
            {
                expression: structure_selection_query_1.StructureSelectionQueries.lipid.expression,
                label: "".concat(labelBase, " - Lipids"),
                type: 'ball-and-stick',
                tag: 'lipid'
            },
            {
                expression: structure_selection_query_1.StructureSelectionQueries.water.expression,
                label: "".concat(labelBase, " - Waters"),
                type: 'ball-and-stick',
                tag: 'water'
            }
        ];
    }
}
exports.createSelectionExpressions = createSelectionExpressions;
var toRange = function (start, end) {
    if (!end)
        return [start];
    var b = start < end ? start : end;
    var e = start < end ? end : start;
    return tslib_1.__spreadArray([], Array(e - b + 1), true).map(function (_, i) { return b + i; });
};
exports.toRange = toRange;
var labelFromProps = function (entryId, labelAsymId, range) {
    return entryId + (labelAsymId ? ".".concat(labelAsymId) : '') +
        (range && range.length > 0 ? ":".concat(range[0]) : '') +
        (range && range.length > 1 ? "-".concat(range[range.length - 1]) : '');
};
function rangeToTest(asymId, residues, operatorName) {
    var chainTests = [builder_1.MolScriptBuilder.core.rel.eq([builder_1.MolScriptBuilder.ammp('label_asym_id'), asymId])];
    if (operatorName)
        chainTests.push(builder_1.MolScriptBuilder.core.rel.eq([operatorName, builder_1.MolScriptBuilder.acp('operatorName')]));
    if (residues.length > 0) {
        return {
            'chain-test': builder_1.MolScriptBuilder.core.logic.and(chainTests),
            'residue-test': builder_1.MolScriptBuilder.core.set.has([builder_1.MolScriptBuilder.set.apply(builder_1.MolScriptBuilder, residues), builder_1.MolScriptBuilder.ammp('label_seq_id')])
        };
    }
    else {
        return { 'chain-test': builder_1.MolScriptBuilder.core.logic.and(chainTests) };
    }
}
exports.rangeToTest = rangeToTest;
function targetToLoci(target, structure) {
    var expression = targetToExpression(target);
    var query = (0, compiler_1.compile)(expression);
    var selection = query(new structure_1.QueryContext(structure));
    return structure_1.StructureSelection.toLociWithSourceUnits(selection);
}
exports.targetToLoci = targetToLoci;
function targetsToExpression(targets) {
    var expressions = targets.map(function (t) { return targetToExpression(t); });
    return builder_1.MolScriptBuilder.struct.combinator.merge(expressions);
}
function targetToExpression(target) {
    var _a;
    var residueTests = [];
    var chainTests = [];
    var tests = Object.create(null);
    if (target.authSeqId) {
        residueTests.push(builder_1.MolScriptBuilder.core.rel.eq([target.authSeqId, builder_1.MolScriptBuilder.ammp('auth_seq_id')]));
    }
    else if (target.labelSeqId) {
        residueTests.push(builder_1.MolScriptBuilder.core.rel.eq([target.labelSeqId, builder_1.MolScriptBuilder.ammp('label_seq_id')]));
    }
    else if (target.labelSeqRange) {
        residueTests.push(builder_1.MolScriptBuilder.core.rel.inRange([builder_1.MolScriptBuilder.ammp('label_seq_id'), target.labelSeqRange.beg, (_a = target.labelSeqRange.end) !== null && _a !== void 0 ? _a : target.labelSeqRange.beg]));
    }
    if (target.labelCompId) {
        residueTests.push(builder_1.MolScriptBuilder.core.rel.eq([target.labelCompId, builder_1.MolScriptBuilder.ammp('label_comp_id')]));
    }
    if (residueTests.length === 1) {
        tests['residue-test'] = residueTests[0];
    }
    else if (residueTests.length > 1) {
        tests['residue-test'] = builder_1.MolScriptBuilder.core.logic.and(residueTests);
    }
    if (target.labelAsymId) {
        chainTests.push(builder_1.MolScriptBuilder.core.rel.eq([target.labelAsymId, builder_1.MolScriptBuilder.ammp('label_asym_id')]));
    }
    if (target.operatorName) {
        chainTests.push(builder_1.MolScriptBuilder.core.rel.eq([target.operatorName, builder_1.MolScriptBuilder.acp('operatorName')]));
    }
    if (chainTests.length === 1) {
        tests['chain-test'] = chainTests[0];
    }
    else if (chainTests.length > 1) {
        tests['chain-test'] = builder_1.MolScriptBuilder.core.logic.and(chainTests);
    }
    if (Object.keys(tests).length > 0) {
        return builder_1.MolScriptBuilder.struct.modifier.union([
            builder_1.MolScriptBuilder.struct.generator.atomGroups(tests)
        ]);
    }
    else {
        return builder_1.MolScriptBuilder.struct.generator.empty;
    }
}
