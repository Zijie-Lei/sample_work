"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Residue = exports.SearchIconSvg = exports.StrucmotifSubmitControls = exports.MAX_EXCHANGES = void 0;
var tslib_1 = require("tslib");
var jsx_runtime_1 = require("react/jsx-runtime");
/**
 * Copyright (c) 2020 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author Sebastian Bittrich <sebastian.bittrich@rcsb.org>
 */
var base_1 = require("molstar/lib/mol-plugin-ui/base");
var common_1 = require("molstar/lib/mol-plugin-ui/controls/common");
var icons_1 = require("molstar/lib/mol-plugin-ui/controls/icons");
var action_menu_1 = require("molstar/lib/mol-plugin-ui/controls/action-menu");
var structure_1 = require("molstar/lib/mol-model/structure/structure");
var selection_1 = require("molstar/lib/mol-plugin-ui/structure/selection");
var int_1 = require("molstar/lib/mol-data/int");
var exchanges_1 = require("./exchanges");
var vec3_1 = require("molstar/lib/mol-math/linear-algebra/3d/vec3");
var ABSOLUTE_ADVANCED_SEARCH_URL = 'https://rcsb.org/search?query=';
var RELATIVE_ADVANCED_SEARCH_URL = '/search?query=';
var RETURN_TYPE = '&return_type=assembly';
var CSM_REGEX = /^[A-Z0-9]+_[A-Z0-9]{6,}$/i;
var CSM_TAG = '&include_csm=true';
var MIN_MOTIF_SIZE = 2;
var MAX_MOTIF_SIZE = 10;
exports.MAX_EXCHANGES = 4;
var MAX_MOTIF_EXTENT = 15;
var MAX_MOTIF_EXTENT_SQUARED = MAX_MOTIF_EXTENT * MAX_MOTIF_EXTENT;
/**
 * The top-level component that exposes the strucmotif search.
 */
var StrucmotifSubmitControls = /** @class */ (function (_super) {
    tslib_1.__extends(StrucmotifSubmitControls, _super);
    function StrucmotifSubmitControls() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    StrucmotifSubmitControls.prototype.defaultState = function () {
        return {
            header: 'Structure Motif Search',
            isCollapsed: false,
            brand: { accent: 'gray', svg: SearchIconSvg }
        };
    };
    StrucmotifSubmitControls.prototype.renderControls = function () {
        return (0, jsx_runtime_1.jsx)(jsx_runtime_1.Fragment, { children: (0, jsx_runtime_1.jsx)(SubmitControls, {}) });
    };
    return StrucmotifSubmitControls;
}(base_1.CollapsableControls));
exports.StrucmotifSubmitControls = StrucmotifSubmitControls;
var _SearchIcon = (0, jsx_runtime_1.jsx)("svg", tslib_1.__assign({ width: '24px', height: '24px', viewBox: '0 0 12 12' }, { children: (0, jsx_runtime_1.jsxs)("g", tslib_1.__assign({ strokeWidth: '1.5', fill: 'none' }, { children: [(0, jsx_runtime_1.jsx)("path", { d: 'M11.29 11.71l-4-4' }), (0, jsx_runtime_1.jsx)("circle", { cx: '5', cy: '5', r: '4' })] })) }));
function SearchIconSvg() { return _SearchIcon; }
exports.SearchIconSvg = SearchIconSvg;
var location = structure_1.StructureElement.Location.create(void 0);
/**
 * The inner component of strucmotif search that can be collapsed.
 */
var SubmitControls = /** @class */ (function (_super) {
    tslib_1.__extends(SubmitControls, _super);
    function SubmitControls() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.state = {
            isBusy: false,
            // map between selection entries of Mol* and additional exchange state
            residueMap: new Map(),
            action: void 0
        };
        _this.submitSearch = function () {
            var _a;
            var _b = structure_1.StructureProperties.atom, label_atom_id = _b.label_atom_id, x = _b.x, y = _b.y, z = _b.z;
            // keep track of seen pdbIds, space-groups, and NCS operators - motifs can only have a single value
            var pdbId = new Set();
            var sg = new Set();
            var hkl = new Set();
            var ncs = new Set();
            var residueIds = [];
            var exchanges = [];
            var coordinates = [];
            /**
             * This sets the 'location' to the backbone atom (CA or C4').
             * @param structure context
             * @param element wraps atom indices of this residue
             */
            var determineBackboneAtom = function (structure, element) {
                var indices = element.indices;
                for (var i = 0, il = int_1.OrderedSet.size(indices); i < il; i++) {
                    structure_1.StructureElement.Location.set(location, structure, element.unit, element.unit.elements[int_1.OrderedSet.getAt(indices, i)]);
                    var atomLabelId = label_atom_id(location);
                    if ('CA' === atomLabelId || "C4'" === atomLabelId) {
                        return true;
                    }
                }
                return false;
            };
            function join(opers) {
                // this makes the assumptions that '1' is the identity operator
                if (!opers || !opers.length)
                    return '1';
                if (opers.length > 1) {
                    // Mol* operators are right-to-left
                    return opers[1] + 'x' + opers[0];
                }
                return opers[0];
            }
            var loci = _this.plugin.managers.structure.selection.additionsHistory;
            for (var i = 0; i < Math.min(MAX_MOTIF_SIZE, loci.length); i++) {
                var l = loci[i];
                var _c = l.loci, structure = _c.structure, elements = _c.elements;
                // only first element and only first index will be considered (ignoring multiple residues)
                if (!determineBackboneAtom(structure, elements[0])) {
                    alert("No CA or C4' atom for ".concat(structure_1.StructureProperties.residue.label_seq_id(location), " | ").concat(structure_1.StructureProperties.chain.label_asym_id(location), " | ").concat(join(structure_1.StructureProperties.unit.pdbx_struct_oper_list_ids(location))));
                    return;
                }
                pdbId.add(structure.model.entry);
                sg.add(structure_1.StructureProperties.unit.spgrOp(location));
                hkl.add(structure_1.StructureProperties.unit.hkl(location).join('-'));
                ncs.add(structure_1.StructureProperties.unit.struct_ncs_oper_id(location));
                var struct_oper_list_ids = structure_1.StructureProperties.unit.pdbx_struct_oper_list_ids(location);
                var struct_oper_id = join(struct_oper_list_ids);
                // handle pure residue-info
                var residueId = {
                    label_asym_id: structure_1.StructureProperties.chain.label_asym_id(location),
                    // can be empty array if model is selected
                    struct_oper_id: struct_oper_id,
                    label_seq_id: structure_1.StructureProperties.residue.label_seq_id(location)
                };
                residueIds.push(residueId);
                // retrieve CA/C4', used to compute residue distance
                var coords = [x(location), y(location), z(location)];
                coordinates.push({ coords: coords, residueId: residueId });
                // handle potential exchanges - can be empty if deselected by users
                var residueMapEntry = _this.state.residueMap.get(l);
                if (((_a = residueMapEntry.exchanges) === null || _a === void 0 ? void 0 : _a.size) > 0) {
                    if (residueMapEntry.exchanges.size > exports.MAX_EXCHANGES) {
                        alert("Maximum number of exchanges per position is ".concat(exports.MAX_EXCHANGES, " - Please remove some exchanges from residue ").concat(residueId.label_seq_id, " | ").concat(residueId.label_asym_id, " | ").concat(residueId.struct_oper_id, "."));
                        return;
                    }
                    exchanges.push({ residue_id: residueId, allowed: Array.from(residueMapEntry.exchanges.values()) });
                }
            }
            if (pdbId.size > 1) {
                alert('Motifs can only be extracted from a single model!');
                return;
            }
            if (sg.size > 1) {
                alert('Motifs can only appear in a single space-group!');
                return;
            }
            if (hkl.size > 1) {
                alert('All motif residues must have matching hkl operators!');
                return;
            }
            if (ncs.size > 1) {
                alert('All motif residues must have matching NCS operators!');
                return;
            }
            if (residueIds.length > MAX_MOTIF_SIZE) {
                alert("Maximum motif size is ".concat(MAX_MOTIF_SIZE, " residues!"));
                return;
            }
            if (residueIds.filter(function (v) { return v.label_seq_id === 0; }).length > 0) {
                alert('Selections may only contain polymeric entities!');
                return;
            }
            // warn if >15 A
            var a = (0, vec3_1.Vec3)();
            var b = (0, vec3_1.Vec3)();
            // this is not efficient but is good enough for up to 10 residues
            for (var i = 0, il = coordinates.length; i < il; i++) {
                vec3_1.Vec3.set(a, coordinates[i].coords[0], coordinates[i].coords[1], coordinates[i].coords[2]);
                var contact = false;
                for (var j = 0, jl = coordinates.length; j < jl; j++) {
                    if (i === j)
                        continue;
                    vec3_1.Vec3.set(b, coordinates[j].coords[0], coordinates[j].coords[1], coordinates[j].coords[2]);
                    var d = vec3_1.Vec3.squaredDistance(a, b);
                    if (d < MAX_MOTIF_EXTENT_SQUARED) {
                        contact = true;
                    }
                }
                if (!contact) {
                    var residueId = coordinates[i].residueId;
                    alert("Residue ".concat(residueId.label_seq_id, " | ").concat(residueId.label_asym_id, " | ").concat(residueId.struct_oper_id, " needs to be less than ").concat(MAX_MOTIF_EXTENT, " \u212B from another residue - Consider adding more residues to connect far-apart residues."));
                    return;
                }
            }
            var entry_id = pdbId.values().next().value;
            var query = {
                type: 'terminal',
                service: 'strucmotif',
                parameters: {
                    value: {
                        entry_id: entry_id,
                        residue_ids: residueIds.sort(function (a, b) { return _this.sortResidueIds(a, b); })
                    },
                    rmsd_cutoff: 2,
                    atom_pairing_scheme: 'ALL'
                }
            };
            if (exchanges.length)
                Object.assign(query.parameters, { exchanges: exchanges });
            // console.log(query);
            var sierraUrl = _this.plugin.customState.detachedFromSierra ? ABSOLUTE_ADVANCED_SEARCH_URL : RELATIVE_ADVANCED_SEARCH_URL;
            var csmTag = CSM_REGEX.test(entry_id) ? CSM_TAG : '';
            var url = sierraUrl + encodeURIComponent(JSON.stringify(query)) + RETURN_TYPE + csmTag;
            // console.log(url);
            window.open(url, '_blank');
        };
        _this.selectAction = function (item) {
            if (!item)
                return;
            (item === null || item === void 0 ? void 0 : item.value)();
        };
        _this.toggleExchanges = function (idx) { return _this.setState({ action: (_this.state.action === idx ? void 0 : idx) }); };
        return _this;
    }
    SubmitControls.prototype.componentDidMount = function () {
        var _this = this;
        this.subscribe(this.selection.events.additionsHistoryUpdated, function () {
            // invalidate potentially expanded exchange panel
            _this.setState({ action: void 0 });
            _this.forceUpdate();
        });
        this.subscribe(this.plugin.behaviors.state.isBusy, function (v) {
            _this.setState({ isBusy: v });
        });
    };
    Object.defineProperty(SubmitControls.prototype, "selection", {
        get: function () {
            return this.plugin.managers.structure.selection;
        },
        enumerable: false,
        configurable: true
    });
    SubmitControls.prototype.sortResidueIds = function (a, b) {
        if (a.label_asym_id !== b.label_asym_id) {
            return a.label_asym_id.localeCompare(b.label_asym_id);
        }
        else if (a.struct_oper_id !== b.struct_oper_id) {
            return a.struct_oper_id.localeCompare(b.struct_oper_id);
        }
        else {
            return a.label_seq_id < b.label_seq_id ? -1 : a.label_seq_id > b.label_seq_id ? 1 : 0;
        }
    };
    Object.defineProperty(SubmitControls.prototype, "actions", {
        get: function () {
            var history = this.selection.additionsHistory;
            return [
                {
                    kind: 'item',
                    label: "Submit Search ".concat(history.length < MIN_MOTIF_SIZE ? ' (' + MIN_MOTIF_SIZE + ' selections required)' : ''),
                    value: this.submitSearch,
                    disabled: history.length < MIN_MOTIF_SIZE
                },
            ];
        },
        enumerable: false,
        configurable: true
    });
    SubmitControls.prototype.highlight = function (loci) {
        this.plugin.managers.interactivity.lociHighlights.highlightOnly({ loci: loci }, false);
    };
    SubmitControls.prototype.moveHistory = function (e, direction) {
        this.setState({ action: void 0 });
        this.plugin.managers.structure.selection.modifyHistory(e.entry, direction, MAX_MOTIF_SIZE);
        this.updateResidues();
    };
    SubmitControls.prototype.modifyHistory = function (e, a) {
        this.setState({ action: void 0 });
        this.plugin.managers.structure.selection.modifyHistory(e.entry, a);
        this.updateResidues();
    };
    SubmitControls.prototype.updateResidues = function () {
        var _this = this;
        var newResidueMap = new Map();
        this.selection.additionsHistory.forEach(function (entry) {
            newResidueMap.set(entry, _this.state.residueMap.get(entry));
        });
        this.setState({ residueMap: newResidueMap });
    };
    SubmitControls.prototype.focusLoci = function (loci) {
        this.plugin.managers.camera.focusLoci(loci);
    };
    SubmitControls.prototype.historyEntry = function (e, idx) {
        var _this = this;
        var history = this.plugin.managers.structure.selection.additionsHistory;
        return (0, jsx_runtime_1.jsxs)("div", { children: [(0, jsx_runtime_1.jsxs)("div", tslib_1.__assign({ className: 'msp-flex-row' }, { children: [(0, jsx_runtime_1.jsxs)(common_1.Button, tslib_1.__assign({ noOverflow: true, title: 'Click to focus. Hover to highlight.', onClick: function () { return _this.focusLoci(e.entry.loci); }, style: { width: 'auto', textAlign: 'left' }, onMouseEnter: function () { return _this.highlight(e.entry.loci); }, onMouseLeave: function () { return _this.plugin.managers.interactivity.lociHighlights.clearHighlights(); } }, { children: [idx, ". ", (0, jsx_runtime_1.jsx)("span", { dangerouslySetInnerHTML: { __html: e.entry.label } })] })), (0, jsx_runtime_1.jsx)(common_1.ToggleButton, { icon: icons_1.TuneSvg, className: 'msp-form-control', title: 'Define exchanges', toggle: function () { return _this.toggleExchanges(idx); }, isSelected: this.state.action === idx, disabled: this.state.isBusy, style: { flex: '0 0 40px', padding: 0 } }), history.length > 1 && (0, jsx_runtime_1.jsx)(common_1.IconButton, { svg: icons_1.ArrowUpwardSvg, small: true, className: 'msp-form-control', onClick: function () { return _this.moveHistory(e, 'up'); }, flex: '20px', title: 'Move up' }), history.length > 1 && (0, jsx_runtime_1.jsx)(common_1.IconButton, { svg: icons_1.ArrowDownwardSvg, small: true, className: 'msp-form-control', onClick: function () { return _this.moveHistory(e, 'down'); }, flex: '20px', title: 'Move down' }), (0, jsx_runtime_1.jsx)(common_1.IconButton, { svg: icons_1.DeleteOutlinedSvg, small: true, className: 'msp-form-control', onClick: function () { return _this.modifyHistory(e, 'remove'); }, flex: true, title: 'Remove' })] })), this.state.action === idx && (0, jsx_runtime_1.jsx)(exchanges_1.ExchangesControl, { handler: e })] }, e.entry.id);
    };
    SubmitControls.prototype.add = function () {
        var history = this.plugin.managers.structure.selection.additionsHistory;
        var entries = [];
        for (var i = 0, _i = Math.min(history.length, 10); i < _i; i++) {
            var residue = void 0;
            if (this.state.residueMap.has(history[i])) {
                residue = this.state.residueMap.get(history[i]);
            }
            else {
                residue = new Residue(history[i], this);
                this.state.residueMap.set(history[i], residue);
            }
            entries.push(this.historyEntry(residue, i + 1));
        }
        return (0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [(0, jsx_runtime_1.jsx)(action_menu_1.ActionMenu, { items: this.actions, onSelect: this.selectAction }), entries.length > 0 && (0, jsx_runtime_1.jsx)("div", tslib_1.__assign({ className: 'msp-control-offset' }, { children: entries })), entries.length === 0 && (0, jsx_runtime_1.jsx)("div", tslib_1.__assign({ className: 'msp-control-offset msp-help-text' }, { children: (0, jsx_runtime_1.jsxs)("div", tslib_1.__assign({ className: 'msp-help-description' }, { children: [(0, jsx_runtime_1.jsx)(icons_1.Icon, { svg: icons_1.HelpOutlineSvg, inline: true }), "Add one or more selections (toggle ", (0, jsx_runtime_1.jsx)(selection_1.ToggleSelectionModeButton, { inline: true }), " mode)"] })) }))] });
    };
    SubmitControls.prototype.render = function () {
        return (0, jsx_runtime_1.jsx)(jsx_runtime_1.Fragment, { children: this.add() });
    };
    return SubmitControls;
}(base_1.PurePluginUIComponent));
var Residue = /** @class */ (function () {
    function Residue(entry, parent) {
        this.entry = entry;
        this.parent = parent;
        this.exchanges = new Set();
        // by default: explicitly 'activate' original residue type
        var structure = entry.loci.structure;
        var e = entry.loci.elements[0];
        structure_1.StructureElement.Location.set(location, structure, e.unit, e.unit.elements[int_1.OrderedSet.getAt(e.indices, 0)]);
        var comp = structure_1.StructureProperties.atom.label_comp_id(location);
        if (exchanges_1.DefaultExchanges.has(comp)) {
            this.exchanges.add(comp);
            return;
        }
    }
    Residue.prototype.toggleExchange = function (val) {
        if (this.hasExchange(val)) {
            this.exchanges.delete(val);
        }
        else {
            if (this.exchanges.size < exports.MAX_EXCHANGES) {
                this.exchanges.add(val);
            }
            else {
                alert("Maximum number of exchanges per position is ".concat(exports.MAX_EXCHANGES));
            }
        }
        // this will update state of parent component
        this.parent.forceUpdate();
    };
    Residue.prototype.hasExchange = function (val) {
        return this.exchanges.has(val);
    };
    return Residue;
}());
exports.Residue = Residue;
